#!/usr/bin/python
# Floris Douw
# 2020
#
# AoC 2020 Day 11: Seating System

import time


class TracedGrid:

    def see_neighbour(self, x, y, dx, dy):
        """
        Look from position (x,y) in the direction defined by (dx,dy).
        Return the position of the first chair we see in this direction.
        Return None if no chairs are visible in this direction.
        Return None if there is no chair in the current position (x,y).
        """
        if self.grid[y][x] == '.' or (dx == 0 and dy == 0):   # Makes looping easier
            return None
        x += dx
        y += dy
        while 0 <= x < self.width and 0 <= y < self.height:
            if self.grid[y][x] != '.':
                return (x, y)
            x += dx
            y += dy
        return None

    def trace_neighbours(self, x, y):
        """
        Does raytracing to find the seats seen by (x,y). Empty places are ignored.
        """
        return list(filter(lambda n: n != None, (self.see_neighbour(x, y, i, j) for i in [-1, 0, 1] for j in [-1, 0, 1])))

    def direct_neighbours(self, x, y):
        """
        Fills the set of neighbours with only adjacent neighbours.
        """
        return [(x+i, y+j) for i in [-1, 0, 1] for j in [-1, 0, 1] if not (x == 0 and y == 0)]

    def __init__(self, input, part):
        self.grid = [[*(line.strip())] for line in input]
        self.width = len(self.grid[0])  # Assume rectangle
        self.height = len(self.grid)
        self.neighbours = {}
        for y in range(self.height):
            for x in range(self.width):
                self.neighbours[(x, y)] = self.trace_neighbours(x, y) if part == 2 else self.direct_neighbours(x, y)

    def is_occupied(self, p):
        """
        Expects a tuple p = (x,y).
        Returns True if this place is occupied, False if it is empty or outside the grid.
        """
        return 0 <= p[0] < self.width and 0 <= p[1] < self.height and self.grid[p[1]][p[0]] == '#'

    def is_available(self, x, y):
        for p in self.neighbours[(x, y)]:
            if self.is_occupied(p):
                return False
        return True

    def update(self):
        """
        Update the grid using the rules in part 2.
        This time using the cached neigbours.
        """
        tmp = [row.copy() for row in self.grid]
        changed = False
        for y in range(self.height):
            for x in range(self.width):
                if self.grid[y][x] == '#' and sum(self.is_occupied(p) for p in self.neighbours[(x, y)]) >= 5:
                    tmp[y][x] = 'L'
                    changed = True
                elif self.grid[y][x] == 'L' and self.is_available(x, y):
                    tmp[y][x] = '#'
                    changed = True
        self.grid = tmp
        return changed

    def count_occupants(self):
        return sum(row.count('#') for row in self.grid)

    def show(self):
        print('\n'.join(''.join(row) for row in self.grid))
        print('')


with open('input/day11', 'r') as f:
    start1 = time.perf_counter()
    grid = TracedGrid(f.readlines(), part=1)
    while grid.update():
        pass
    end1 = time.perf_counter()
    print(f'Part 1: {grid.count_occupants()}')

with open('input/day11', 'r') as f:
    start2 = time.perf_counter()
    grid = TracedGrid(f.readlines(), part=2)
    while grid.update():
        pass
    end2 = time.perf_counter()
    print(f'Part 2: {grid.count_occupants()}')

print(f'Time part 1: {end1-start1:1.3}s')
print(f'Time part 2: {end2-start2:1.3}s')
